:py:mod:`advent_of_code.protocols`
==================================

.. py:module:: advent_of_code.protocols


Module Contents
---------------

.. py:class:: AdventOfCodeProblem


   Bases: :py:obj:`Protocol`

   Base class for protocol classes.

   Protocol classes are defined as::

       class Proto(Protocol):
           def meth(self) -> int:
               ...

   Such classes are primarily used with static type checkers that recognize
   structural subtyping (static duck-typing).

   For example::

       class C:
           def meth(self) -> int:
               return 0

       def func(x: Proto) -> int:
           return x.meth()

       func(C())  # Passes static type check

   See PEP 544 for details. Protocol classes decorated with
   @typing.runtime_checkable act as simple-minded runtime protocols that check
   only the presence of given attributes, ignoring their type signatures.
   Protocol classes can be generic, they are defined as::

       class GenProto[T](Protocol):
           def meth(self) -> T:
               ...

   .. py:attribute:: year
      :type: int

      

   .. py:attribute:: day
      :type: int

      

   .. py:attribute:: tag
      :type: str
      :value: 'v1'

      

   .. py:method:: solve_part_1(puzzle_input: PuzzleInputT) -> int | str
      :abstractmethod:


   .. py:method:: solve_part_2(puzzle_input: PuzzleInputT) -> int | str
      :abstractmethod:


   .. py:method:: parse_text_input(text: str) -> PuzzleInputT
      :staticmethod:
      :abstractmethod:


   .. py:method:: parse_input_text_file() -> PuzzleInputT


   .. py:method:: solve(part_1: bool = True, part_2: bool = True)



.. py:class:: ExampleAdventOfCodePuzzleInput202206


   .. py:attribute:: number
      :type: int

      


.. py:class:: ExampleAdventOfCodePuzzleInput202207


   .. py:attribute:: number_bis
      :type: int

      


.. py:class:: ExampleAdventOfCodeProblem202206


   Bases: :py:obj:`AdventOfCodeProblem`\ [\ :py:obj:`ExampleAdventOfCodePuzzleInput202206`\ ]

   Base class for protocol classes.

   Protocol classes are defined as::

       class Proto(Protocol):
           def meth(self) -> int:
               ...

   Such classes are primarily used with static type checkers that recognize
   structural subtyping (static duck-typing).

   For example::

       class C:
           def meth(self) -> int:
               return 0

       def func(x: Proto) -> int:
           return x.meth()

       func(C())  # Passes static type check

   See PEP 544 for details. Protocol classes decorated with
   @typing.runtime_checkable act as simple-minded runtime protocols that check
   only the presence of given attributes, ignoring their type signatures.
   Protocol classes can be generic, they are defined as::

       class GenProto[T](Protocol):
           def meth(self) -> T:
               ...

   .. py:attribute:: year
      :type: int

      

   .. py:attribute:: day
      :type: int

      

   .. py:attribute:: tag
      :type: str
      :value: 'retest'

      

   .. py:method:: solve_part_1(puzzle_input: ExampleAdventOfCodePuzzleInput202206)


   .. py:method:: solve_part_2(puzzle_input: ExampleAdventOfCodePuzzleInput202206)


   .. py:method:: parse_text_input(text: str) -> ExampleAdventOfCodePuzzleInput202206
      :staticmethod:



.. py:class:: ExampleAdventOfCodeProblem202207


   .. py:attribute:: year
      :type: int

      

   .. py:attribute:: day
      :type: int

      

   .. py:attribute:: tag
      :type: str
      :value: 'v1'

      

   .. py:method:: solve_part_1(puzzle_input: ExampleAdventOfCodePuzzleInput202207) -> int


   .. py:method:: solve_part_2(puzzle_input: ExampleAdventOfCodePuzzleInput202207) -> str


   .. py:method:: parse_text_input(text: str) -> ExampleAdventOfCodePuzzleInput202207
      :staticmethod:


   .. py:method:: parse_input_text_file() -> ExampleAdventOfCodePuzzleInput202207


   .. py:method:: solve(part_1: bool = True, part_2: bool = True)



.. py:function:: function_that_solve_part_1(problem: AdventOfCodeProblem[function_that_solve_part_1.PuzzleInputT], puzzle_input: function_that_solve_part_1.PuzzleInputT) -> int | str


.. py:data:: problem

   

