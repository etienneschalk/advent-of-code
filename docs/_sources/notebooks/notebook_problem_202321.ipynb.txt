{
    "cells": [
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "# Year 2023 Day 21"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "import numpy as np\n",
                "import xarray as xr\n",
                "import hvplot.xarray  # pyright: ignore[reportUnusedImport,reportMissingTypeStubs]\n",
                "from pathlib import Path\n",
                "from advent_of_code.common.common import get_puzzle_input_file_path, numpy_2d_to_xarray_row_col\n",
                "from advent_of_code.y_2023.problem_202321 import (\n",
                "    parse_text_input,\n",
                ")\n",
                "from advent_of_code.y_2023.problem_202321 import (\n",
                "    get_starting_position,\n",
                "    run_steps_details,\n",
                "    create_diamond_int_array,\n",
                "    create_diamond_mask_array,\n",
                "    get_free_cells_xda,\n",
                "    evaluate_quadratic_equation,\n",
                "    compute_points_for_interpolation,\n",
                ")"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## With Mock Input"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "full_size = True \n",
                "side = 131 if full_size else 11\n",
                "middle = 65 if full_size else 5 \n",
                "\n",
                "arr = np.zeros((side, side), dtype=np.bool_)\n",
                "assert side // 2 == middle\n",
                "starting_pos  = middle\n",
                "arr[middle][middle] # starting pos"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "diamond_array = create_diamond_int_array(numpy_2d_to_xarray_row_col(arr))\n",
                "diamond_array"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "diamond_array[middle]"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "diamond_mask = create_diamond_mask_array(diamond_array)\n",
                "diamond_mask.hvplot.image(y=\"row\", x=\"col\", data_aspect=1, cmap=\"viridis\")"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "top_left = diamond_mask[:middle, :middle]\n",
                "top_left"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "top_left = diamond_mask[:middle+2, :middle+2]\n",
                "top_left"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "## With Actual Input"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "text = (get_puzzle_input_file_path(2023, 21)).read_text()\n",
                "garden = parse_text_input(text)\n",
                "garden.coords"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "free = get_free_cells_xda(garden)"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "free.hvplot.image(y=\"row\", x=\"col\", data_aspect=1, cmap=\"viridis\")"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "(~free).hvplot.image(y=\"row\", x=\"col\", data_aspect=1, cmap=\"viridis\")"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "create_diamond_mask_array(free).hvplot.image(y=\"row\", x=\"col\", data_aspect=1, cmap=\"viridis\")"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### Observation on Data\n",
                "\n",
                "- All edges are free\n",
                "- The middle row and middle cols are free\n",
                "- Presence of a diagonal path\n",
                "\n",
                "Hence the image can be safely divided into 8 half-quadrants"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "free.coords"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "assert free.shape == (side, side)\n",
                "assert (free[0]).all().item()\n",
                "assert (free[-1]).all().item()\n",
                "assert (free[:, 0]).all().item()\n",
                "assert (free[:, -1]).all().item()\n",
                "assert free[middle].all().item()\n",
                "assert free[:, middle].all().item()"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "initial_pos = get_starting_position(garden)\n",
                "max_iter = 65 * 2\n",
                "\n",
                "history, reached, reached_even_xda, reached_odd_xda = run_steps_details(garden, initial_pos, max_iter)"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "reached_odd_xda.hvplot.image(y=\"row\", x=\"col\", data_aspect=1, cmap=\"viridis\")"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "reached_even_xda.hvplot.image(y=\"row\", x=\"col\", data_aspect=1, cmap=\"viridis\")"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### Check part 1 can be found again"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "max_iter = 64 # we will want the even\n",
                "_, _, reached_even_xda_p1, reached_odd_xda_p1 = run_steps_details(\n",
                "    garden, initial_pos, max_iter\n",
                ")"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "diamond_1x1 = create_diamond_mask_array(reached_even_xda_p1)\n",
                "diamond_1x1.hvplot.image(y=\"row\", x=\"col\", data_aspect=1, cmap=\"viridis\")"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "assert reached_even_xda_p1.where(diamond_1x1, 0).sum() == 3740"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### 1x1"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "odd = reached_odd_xda\n",
                "eve = reached_even_xda"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "odd.where(create_diamond_mask_array(odd), 0).sum().item()"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "assert eve.where(create_diamond_mask_array(eve), 0).sum().item() == 3740 \n",
                "# Part 1 also works when using the eve diagram (as 65 = 64 + 1, we juste iterated one more time)"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "concat_1 = odd\n",
                "diamond_1x1 = create_diamond_mask_array(concat_1)"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### 3x3 concat\n",
                "\n",
                "Note: The step count is **EVEN**, so the even array must be placed back at the center of the mosaic.\n",
                "This cellular automata kind of \"flips\" every turn.\n"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": []
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "assert middle + 1 * odd.row.size == 196  # 65 + 1 * 131"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "new_coords3 = list(range(3 * odd.row.size))\n",
                "concat_3 = xr.concat(\n",
                "    [\n",
                "        xr.concat([eve, odd, eve], dim=\"col\"),\n",
                "        xr.concat([odd, eve, odd], dim=\"col\"),\n",
                "        xr.concat([eve, odd, eve], dim=\"col\"),\n",
                "    ],\n",
                "    dim=\"row\",\n",
                ").assign_coords(dict(row=new_coords3, col=new_coords3))\n",
                "concat_3"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "concat_3.hvplot.image(y=\"row\", x=\"col\", data_aspect=1, cmap=\"viridis\")"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "diamond_3x3 = create_diamond_mask_array(concat_3)\n",
                "diamond_3x3.hvplot.image(y=\"row\", x=\"col\", data_aspect=1, cmap=\"viridis\")"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "concat_3.where(diamond_3x3, 0).sum().item()"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "concat_3"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### 5x5 concat\n",
                "\n",
                "Note: The step count is odd, so odd must be placed back at the center of the mosaic"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "assert middle + 2 * odd.row.size == 327 # 65 + 2 * 131"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "new_coords5 = list(range(5 * odd.row.size))\n",
                "concat_5 = xr.concat(\n",
                "    [\n",
                "        xr.concat([odd, eve, odd, eve, odd], dim=\"col\"),\n",
                "        xr.concat([eve, odd, eve, odd, eve], dim=\"col\"),\n",
                "        xr.concat([odd, eve, odd, eve, odd], dim=\"col\"),\n",
                "        xr.concat([eve, odd, eve, odd, eve], dim=\"col\"),\n",
                "        xr.concat([odd, eve, odd, eve, odd], dim=\"col\"),\n",
                "    ],\n",
                "    dim=\"row\",\n",
                ").assign_coords(dict(row=new_coords5, col=new_coords5))\n",
                "concat_5"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "concat_5.hvplot.image(y=\"row\", x=\"col\", data_aspect=1, cmap=\"viridis\")"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "diamond_5x5 = create_diamond_mask_array(concat_5)\n",
                "diamond_5x5.hvplot.image(y=\"row\", x=\"col\", data_aspect=1, cmap=\"viridis\")"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "concat_5.where(diamond_5x5, 0).sum().item()"
            ]
        },
        {
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                "### Interpolation"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "x, y = compute_points_for_interpolation(\n",
                "    concat_1, diamond_1x1, concat_3, diamond_3x3, concat_5, diamond_5x5\n",
                ")"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "assert evaluate_quadratic_equation(x, y, 0) == y[0]\n",
                "assert evaluate_quadratic_equation(x, y, 1) == y[1]\n",
                "assert evaluate_quadratic_equation(x, y, 2) == y[2]"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "result = evaluate_quadratic_equation(x, y, 26501365 // 131)"
            ]
        },
        {
            "cell_type": "code",
            "execution_count": null,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Too high\n",
                "# The error was because I forgot to put the even array at the center of the 3x3 mosaic\n",
                "# Each macro step changes the parity\n",
                "assert result < 635572702833258\n",
                "result"
            ]
        }
    ],
    "metadata": {
        "kernelspec": {
            "display_name": "advent-of-code-CEbbwEIT-py3.10",
            "language": "python",
            "name": "python3"
        },
        "language_info": {
            "codemirror_mode": {
                "name": "ipython",
                "version": 3
            },
            "file_extension": ".py",
            "mimetype": "text/x-python",
            "name": "python",
            "nbconvert_exporter": "python",
            "pygments_lexer": "ipython3",
            "version": "3.12.1"
        }
    },
    "nbformat": 4,
    "nbformat_minor": 2
}
